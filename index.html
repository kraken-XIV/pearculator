<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PEARCULATOR 9000â„¢</title>
  <style>
    /* Existing styles omitted for brevity */
    @media (max-width: 768px) {
      .container {
        padding: 5px;
      }
      .input-row {
        flex-direction: column;
        align-items: flex-start;
      }
      input, select, button {
        width: 100%;
      }
    }
    button:focus {
      outline: 2px solid #10b981;
    }
  </style>
</head>
<body>
  <!-- Existing body content omitted for brevity -->
  <script>
    let ethPrice = 0;
    let pearPrice = 0;

    // Show error popup with improved visibility
    function showErrorPopup(message = "Data could not be fetched; fill in fields manually") {
      const popup = document.getElementById('errorPopup');
      popup.textContent = message;
      popup.style.display = 'block';
      setTimeout(() => popup.style.display = 'none', 5000);
    }

    // Fetch live prices with better error handling
    async function fetchLiveData() {
      try {
        const response = await fetch("https://api.coingecko.com/api/v3/simple/price?ids=ethereum,pear-protocol&vs_currencies=usd");
        if (!response.ok) throw new Error(`API returned status: ${response.status}`);
        const data = await response.json();

        if (!data.ethereum || !data["pear-protocol"]) throw new Error("Malformed data received");

        ethPrice = data.ethereum.usd;
        pearPrice = data["pear-protocol"].usd;

        document.getElementById("ethPrice").value = ethPrice.toFixed(2);
        document.getElementById("pearPrice").value = pearPrice.toFixed(2);
      } catch (error) {
        console.error('Error fetching live data:', error);
        showErrorPopup("Unable to fetch live prices. Enter manually.");
        document.getElementById("ethPrice").disabled = false;
        document.getElementById("pearPrice").disabled = false;
      }
    }

    // Helper function to get input values safely
    function getInputValue(id, fallback = 0) {
      const value = parseFloat(document.getElementById(id).value);
      return isNaN(value) ? fallback : value;
    }

    // Perform calculations with better validation
    function calculate() {
      const ethPriceInput = getInputValue("ethPrice", ethPrice);
      const pearPriceInput = getInputValue("pearPrice", pearPrice);
      const blockchainVolumeInput = getInputValue("blockchainVolume");
      const captureRate = getInputValue("captureRate") / 100;
      const rebate = getInputValue("rebate") / 100;
      const stakedPEAR = getInputValue("stakedPEAR") * 1_000_000;
      const avgAPY = getInputValue("avgAPY") / 100;

      if (blockchainVolumeInput <= 0 || captureRate <= 0 || stakedPEAR <= 0 || avgAPY <= 0) {
        showErrorPopup("Please fill in all required fields with valid values.");
        return;
      }

      const capturedVolume = blockchainVolumeInput * captureRate;
      const grossFees = capturedVolume * 0.0026;
      const netFees = grossFees * (1 - rebate);
      const stakerRevenue = netFees * 0.8;

      const dailyEthPayout = stakerRevenue / ethPriceInput;
      const annualEthPerPear = ((dailyEthPayout / stakedPEAR) * 365) * avgAPY;
      const totalAnnualEth = dailyEthPayout * 365;

      document.getElementById("output").innerHTML = `
        <p><strong>Gross Fees:</strong> $${grossFees.toFixed(2)}</p>
        <p><strong>Net Fees (After Rebate):</strong> $${netFees.toFixed(2)}</p>
        <p><strong>Staker Revenue:</strong> $${stakerRevenue.toFixed(2)}</p>
        <p><strong>Daily ETH Payout:</strong> ${dailyEthPayout.toFixed(8)} ETH</p>
        <p><strong>Annual ETH Per PEAR (Including APY):</strong> ${annualEthPerPear.toFixed(8)} ETH</p>
        <p><strong>Total Annual ETH Earned by PEAR:</strong> ${totalAnnualEth.toFixed(2)} ETH</p>
      `;
    }

    // Fetch data on page load with a loading spinner
    document.addEventListener("DOMContentLoaded", () => {
      fetchLiveData();
    });
  </script>
</body>
</html>
